/* eslint-disable no-multi-spaces */
/* eslint-disable no-unused-expressions */
/* eslint-disable no-bitwise */
/* eslint-disable max-len */
/* eslint-disable no-underscore-dangle */
/* eslint-disable func-names */
/*! svg.resize.js v1.4.3 MIT */
//! function(){"use strict";(function(){function t(t){t.remember("_resizeHandler",this),this.el=t,this.parameters={},this.lastUpdateCall=null,this.p=t.doc().node.createSVGPoint()}t.prototype.transformPoint=function(t,e,i){return this.p.x=t-(this.offset.x-window.pageXOffset),this.p.y=e-(this.offset.y-window.pageYOffset),this.p.matrixTransform(i||this.m)},t.prototype._extractPosition=function(t){return{x:null!=t.clientX?t.clientX:t.touches[0].clientX,y:null!=t.clientY?t.clientY:t.touches[0].clientY}},t.prototype.init=function(t){var e=this;if(this.stop(),"stop"!==t){this.options={};for(var i in this.el.resize.defaults)this.options[i]=this.el.resize.defaults[i],void 0!==t[i]&&(this.options[i]=t[i]);this.el.on("lt.resize",function(t){e.resize(t||window.event)}),this.el.on("rt.resize",function(t){e.resize(t||window.event)}),this.el.on("rb.resize",function(t){e.resize(t||window.event)}),this.el.on("lb.resize",function(t){e.resize(t||window.event)}),this.el.on("t.resize",function(t){e.resize(t||window.event)}),this.el.on("r.resize",function(t){e.resize(t||window.event)}),this.el.on("b.resize",function(t){e.resize(t||window.event)}),this.el.on("l.resize",function(t){e.resize(t||window.event)}),this.el.on("rot.resize",function(t){e.resize(t||window.event)}),this.el.on("point.resize",function(t){e.resize(t||window.event)}),this.update()}},t.prototype.stop=function(){return this.el.off("lt.resize"),this.el.off("rt.resize"),this.el.off("rb.resize"),this.el.off("lb.resize"),this.el.off("t.resize"),this.el.off("r.resize"),this.el.off("b.resize"),this.el.off("l.resize"),this.el.off("rot.resize"),this.el.off("point.resize"),this},t.prototype.resize=function(t){var e=this;this.m=this.el.node.getScreenCTM().inverse(),this.offset={x:window.pageXOffset,y:window.pageYOffset};var i=this._extractPosition(t.detail.event);if(this.parameters={type:this.el.type,p:this.transformPoint(i.x,i.y),x:t.detail.x,y:t.detail.y,box:this.el.bbox(),rotation:this.el.transform().rotation},"text"===this.el.type&&(this.parameters.fontSize=this.el.attr()["font-size"]),void 0!==t.detail.i){var s=this.el.array().valueOf();this.parameters.i=t.detail.i,this.parameters.pointCoords=[s[t.detail.i][0],s[t.detail.i][1]]}switch(t.type){case"lt":this.calc=function(t,e){var i=this.snapToGrid(t,e);if(this.parameters.box.width-i[0]>0&&this.parameters.box.height-i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x+i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize-i[0]);i=this.checkAspectRatio(i),this.el.move(this.parameters.box.x+i[0],this.parameters.box.y+i[1]).size(this.parameters.box.width-i[0],this.parameters.box.height-i[1])}};break;case"rt":this.calc=function(t,e){var i=this.snapToGrid(t,e,2);if(this.parameters.box.width+i[0]>0&&this.parameters.box.height-i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x-i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize+i[0]);i=this.checkAspectRatio(i,!0),this.el.move(this.parameters.box.x,this.parameters.box.y+i[1]).size(this.parameters.box.width+i[0],this.parameters.box.height-i[1])}};break;case"rb":this.calc=function(t,e){var i=this.snapToGrid(t,e,0);if(this.parameters.box.width+i[0]>0&&this.parameters.box.height+i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x-i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize+i[0]);i=this.checkAspectRatio(i),this.el.move(this.parameters.box.x,this.parameters.box.y).size(this.parameters.box.width+i[0],this.parameters.box.height+i[1])}};break;case"lb":this.calc=function(t,e){var i=this.snapToGrid(t,e,1);if(this.parameters.box.width-i[0]>0&&this.parameters.box.height+i[1]>0){if("text"===this.parameters.type)return this.el.move(this.parameters.box.x+i[0],this.parameters.box.y),void this.el.attr("font-size",this.parameters.fontSize-i[0]);i=this.checkAspectRatio(i,!0),this.el.move(this.parameters.box.x+i[0],this.parameters.box.y).size(this.parameters.box.width-i[0],this.parameters.box.height+i[1])}};break;case"t":this.calc=function(t,e){var i=this.snapToGrid(t,e,2);if(this.parameters.box.height-i[1]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x,this.parameters.box.y+i[1]).height(this.parameters.box.height-i[1])}};break;case"r":this.calc=function(t,e){var i=this.snapToGrid(t,e,0);if(this.parameters.box.width+i[0]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x,this.parameters.box.y).width(this.parameters.box.width+i[0])}};break;case"b":this.calc=function(t,e){var i=this.snapToGrid(t,e,0);if(this.parameters.box.height+i[1]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x,this.parameters.box.y).height(this.parameters.box.height+i[1])}};break;case"l":this.calc=function(t,e){var i=this.snapToGrid(t,e,1);if(this.parameters.box.width-i[0]>0){if("text"===this.parameters.type)return;this.el.move(this.parameters.box.x+i[0],this.parameters.box.y).width(this.parameters.box.width-i[0])}};break;case"rot":this.calc=function(t,e){var i={x:t+this.parameters.p.x,y:e+this.parameters.p.y},s=Math.atan2(this.parameters.p.y-this.parameters.box.y-this.parameters.box.height/2,this.parameters.p.x-this.parameters.box.x-this.parameters.box.width/2),r=Math.atan2(i.y-this.parameters.box.y-this.parameters.box.height/2,i.x-this.parameters.box.x-this.parameters.box.width/2),a=this.parameters.rotation+180*(r-s)/Math.PI+this.options.snapToAngle/2;this.el.center(this.parameters.box.cx,this.parameters.box.cy).rotate(a-a%this.options.snapToAngle,this.parameters.box.cx,this.parameters.box.cy)};break;case"point":this.calc=function(t,e){var i=this.snapToGrid(t,e,this.parameters.pointCoords[0],this.parameters.pointCoords[1]),s=this.el.array().valueOf();s[this.parameters.i][0]=this.parameters.pointCoords[0]+i[0],s[this.parameters.i][1]=this.parameters.pointCoords[1]+i[1],this.el.plot(s)}}this.el.fire("resizestart",{dx:this.parameters.x,dy:this.parameters.y,event:t}),SVG.on(window,"touchmove.resize",function(t){e.update(t||window.event)}),SVG.on(window,"touchend.resize",function(){e.done()}),SVG.on(window,"mousemove.resize",function(t){e.update(t||window.event)}),SVG.on(window,"mouseup.resize",function(){e.done()})},t.prototype.update=function(t){if(!t)return void(this.lastUpdateCall&&this.calc(this.lastUpdateCall[0],this.lastUpdateCall[1]));var e=this._extractPosition(t),i=this.transformPoint(e.x,e.y),s=i.x-this.parameters.p.x,r=i.y-this.parameters.p.y;this.lastUpdateCall=[s,r],this.calc(s,r),this.el.fire("resizing",{dx:s,dy:r,event:t})},t.prototype.done=function(){this.lastUpdateCall=null,SVG.off(window,"mousemove.resize"),SVG.off(window,"mouseup.resize"),SVG.off(window,"touchmove.resize"),SVG.off(window,"touchend.resize"),this.el.fire("resizedone")},t.prototype.snapToGrid=function(t,e,i,s){var r;return void 0!==s?r=[(i+t)%this.options.snapToGrid,(s+e)%this.options.snapToGrid]:(i=null==i?3:i,r=[(this.parameters.box.x+t+(1&i?0:this.parameters.box.width))%this.options.snapToGrid,(this.parameters.box.y+e+(2&i?0:this.parameters.box.height))%this.options.snapToGrid]),t<0&&(r[0]-=this.options.snapToGrid),e<0&&(r[1]-=this.options.snapToGrid),t-=Math.abs(r[0])<this.options.snapToGrid/2?r[0]:r[0]-(t<0?-this.options.snapToGrid:this.options.snapToGrid),e-=Math.abs(r[1])<this.options.snapToGrid/2?r[1]:r[1]-(e<0?-this.options.snapToGrid:this.options.snapToGrid),this.constraintToBox(t,e,i,s)},t.prototype.constraintToBox=function(t,e,i,s){var r,a,o=this.options.constraint||{};return void 0!==s?(r=i,a=s):(r=this.parameters.box.x+(1&i?0:this.parameters.box.width),a=this.parameters.box.y+(2&i?0:this.parameters.box.height)),void 0!==o.minX&&r+t<o.minX&&(t=o.minX-r),void 0!==o.maxX&&r+t>o.maxX&&(t=o.maxX-r),void 0!==o.minY&&a+e<o.minY&&(e=o.minY-a),void 0!==o.maxY&&a+e>o.maxY&&(e=o.maxY-a),[t,e]},t.prototype.checkAspectRatio=function(t,e){if(!this.options.saveAspectRatio)return t;var i=t.slice(),s=this.parameters.box.width/this.parameters.box.height,r=this.parameters.box.width+t[0],a=this.parameters.box.height-t[1],o=r/a;return o<s?(i[1]=r/s-this.parameters.box.height,e&&(i[1]=-i[1])):o>s&&(i[0]=this.parameters.box.width-a*s,e&&(i[0]=-i[0])),i},SVG.extend(SVG.Element,{resize:function(e){return(this.remember("_resizeHandler")||new t(this)).init(e||{}),this}}),SVG.Element.prototype.resize.defaults={snapToAngle:.1,snapToGrid:1,constraint:{},saveAspectRatio:!1}}).call(this)}();

(function () {
    function ResizeHandler(el) {
        el.remember('_resizeHandler', this);

        this.el = el;
        this.parameters = {};
        this.lastUpdateCall = null;
        this.p = el.doc().node.createSVGPoint();
    }

    ResizeHandler.prototype.transformPoint = function (x, y, m) {
        this.p.x = x - (this.offset.x - window.pageXOffset);
        this.p.y = y - (this.offset.y - window.pageYOffset);

        return this.p.matrixTransform(m || this.m);
    };

    ResizeHandler.prototype._extractPosition = function (event) {
        // Extract a position from a mouse/touch event.
        // Returns { x: .., y: .. }
        return {
            x: event.clientX != null ? event.clientX : event.touches[0].clientX,
            y: event.clientY != null ? event.clientY : event.touches[0].clientY,
        };
    };

    ResizeHandler.prototype.init = function (options) {
        const _this = this;

        this.stop();

        if (options === 'stop') {
            return;
        }

        this.options = {};

        // Merge options and defaults
        for (const i in this.el.resize.defaults) {
            this.options[i] = this.el.resize.defaults[i];
            if (typeof options[i] !== 'undefined') {
                this.options[i] = options[i];
            }
        }

        // We listen to all these events which are specifying different edges
        this.el.on('lt.resize', (e) => { _this.resize(e || window.event); }); // Left-Top
        this.el.on('rt.resize', (e) => { _this.resize(e || window.event); }); // Right-Top
        this.el.on('rb.resize', (e) => { _this.resize(e || window.event); }); // Right-Bottom
        this.el.on('lb.resize', (e) => { _this.resize(e || window.event); }); // Left-Bottom

        this.el.on('t.resize', (e) => { _this.resize(e || window.event); }); // Top
        this.el.on('r.resize', (e) => { _this.resize(e || window.event); }); // Right
        this.el.on('b.resize', (e) => { _this.resize(e || window.event); }); // Bottom
        this.el.on('l.resize', (e) => { _this.resize(e || window.event); }); // Left

        this.el.on('rot.resize', (e) => { _this.resize(e || window.event); }); // Rotation

        this.el.on('point.resize', (e) => { _this.resize(e || window.event); }); // Point-Moving

        // This call ensures, that the plugin reacts to a change of snapToGrid immediately
        this.update();
    };

    ResizeHandler.prototype.stop = function () {
        this.el.off('lt.resize');
        this.el.off('rt.resize');
        this.el.off('rb.resize');
        this.el.off('lb.resize');

        this.el.off('t.resize');
        this.el.off('r.resize');
        this.el.off('b.resize');
        this.el.off('l.resize');

        this.el.off('rot.resize');

        this.el.off('point.resize');

        return this;
    };

    /**
     * @param {CustomEvent}
     */
    ResizeHandler.prototype.resize = function (event) {
        const _this = this;

        this.m = this.el.node.getScreenCTM().inverse();
        this.offset = { x: window.pageXOffset, y: window.pageYOffset };

        const txPt = this._extractPosition(event.detail.event);
        this.parameters = {
            type: this.el.type, // the type of element
            p: this.transformPoint(txPt.x, txPt.y),
            x: event.detail.x, // x-position of the mouse when resizing started
            y: event.detail.y, // y-position of the mouse when resizing started
            box: this.el.bbox(), // The bounding-box of the element
            rotation: this.el.transform().rotation, // The current rotation of the element
        };

        // Add font-size parameter if the element type is text
        if (this.el.type === 'text') {
            this.parameters.fontSize = this.el.attr()['font-size'];
        }

        // the i-param in the event holds the index of the point which is moved, when using `deepSelect`
        if (event.detail.i !== undefined) {
            // get the point array
            const array = this.el.array().valueOf();

            // Save the index and the point which is moved
            this.parameters.i = event.detail.i;
            this.parameters.pointCoords = [array[event.detail.i][0], array[event.detail.i][1]];
        }

        // Lets check which edge of the bounding-box was clicked and resize the this.el according to this
        // eslint-disable-next-line default-case
        switch (event.type) {
        // Left-Top-Edge
        case 'lt':
            // We build a calculating function for every case which gives us the new position of the this.el
            this.calc = function (diffX, diffY) {
                // The procedure is always the same
                // First we snap the edge to the given grid (snapping to 1px grid is normal resizing)
                let snap = this.snapToGrid(diffX, diffY);

                // Now we check if the new height and width still valid (> 0)
                if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {
                    // ...if valid, we resize the this.el (which can include
                    // moving because the coord-system starts at the left-top
                    // and this edge is moving sometimes when resized)

                    /*
                     * but first check if the element is text box, so we can change the font size instead of
                     * the width and height
                     */

                    if (this.parameters.type === 'text') {
                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);
                        this.el.attr('font-size', this.parameters.fontSize - snap[0]);
                        return;
                    }

                    snap = this.checkAspectRatio(snap);

                    this.el
                        .move(this.parameters.box.x + snap[0], this.parameters.box.y + snap[1])
                        .size(this.parameters.box.width - snap[0], this.parameters.box.height - snap[1]);
                }
            };
            break;

        // Right-Top
        case 'rt':
            // s.a.
            this.calc = function (diffX, diffY) {
                let snap = this.snapToGrid(diffX, diffY, 1 << 1);
                if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {
                    if (this.parameters.type === 'text') {
                        this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);
                        this.el.attr('font-size', this.parameters.fontSize + snap[0]);
                        return;
                    }

                    snap = this.checkAspectRatio(snap, true);

                    this.el
                        .move(this.parameters.box.x, this.parameters.box.y + snap[1])
                        .size(this.parameters.box.width + snap[0], this.parameters.box.height - snap[1]);
                }
            };
            break;

        // Right-Bottom
        case 'rb':
            // s.a.
            this.calc = function (diffX, diffY) {
                let snap = this.snapToGrid(diffX, diffY, 0);
                if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {
                    if (this.parameters.type === 'text') {
                        this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);
                        this.el.attr('font-size', this.parameters.fontSize + snap[0]);
                        return;
                    }

                    snap = this.checkAspectRatio(snap);

                    this.el
                        .move(this.parameters.box.x, this.parameters.box.y)
                        .size(this.parameters.box.width + snap[0], this.parameters.box.height + snap[1]);
                }
            };
            break;

        // Left-Bottom
        case 'lb':
            // s.a.
            this.calc = function (diffX, diffY) {
                let snap = this.snapToGrid(diffX, diffY, 1);
                if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {
                    if (this.parameters.type === 'text') {
                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);
                        this.el.attr('font-size', this.parameters.fontSize - snap[0]);
                        return;
                    }

                    snap = this.checkAspectRatio(snap, true);

                    this.el
                        .move(this.parameters.box.x + snap[0], this.parameters.box.y)
                        .size(this.parameters.box.width - snap[0], this.parameters.box.height + snap[1]);
                }
            };
            break;

        // Top
        case 't':
            // s.a.
            this.calc = function (diffX, diffY) {
                const snap = this.snapToGrid(diffX, diffY, 1 << 1);
                if (this.parameters.box.height - snap[1] > 0) {
                    // Disable the font-resizing if it is not from the corner of bounding-box
                    if (this.parameters.type === 'text') {
                        return;
                    }

                    this.el
                        .move(this.parameters.box.x, this.parameters.box.y + snap[1])
                        .height(this.parameters.box.height - snap[1]);
                }
            };
            break;

        // Right
        case 'r':
            // s.a.
            this.calc = function (diffX, diffY) {
                const snap = this.snapToGrid(diffX, diffY, 0);
                if (this.parameters.box.width + snap[0] > 0) {
                    if (this.parameters.type === 'text') {
                        return;
                    }

                    this.el
                        .move(this.parameters.box.x, this.parameters.box.y)
                        .width(this.parameters.box.width + snap[0]);
                }
            };
            break;

        // Bottom
        case 'b':
            // s.a.
            this.calc = function (diffX, diffY) {
                const snap = this.snapToGrid(diffX, diffY, 0);
                if (this.parameters.box.height + snap[1] > 0) {
                    if (this.parameters.type === 'text') {
                        return;
                    }

                    this.el
                        .move(this.parameters.box.x, this.parameters.box.y)
                        .height(this.parameters.box.height + snap[1]);
                }
            };
            break;

        // Left
        case 'l':
            // s.a.
            this.calc = function (diffX, diffY) {
                const snap = this.snapToGrid(diffX, diffY, 1);
                if (this.parameters.box.width - snap[0] > 0) {
                    if (this.parameters.type === 'text') {
                        return;
                    }

                    this.el
                        .move(this.parameters.box.x + snap[0], this.parameters.box.y)
                        .width(this.parameters.box.width - snap[0]);
                }
            };
            break;

        // Rotation
        case 'rot':
            // s.a.
            this.calc = function (diffX, diffY) {
                // yes this is kinda stupid but we need the mouse coords back...
                const current = { x: diffX + this.parameters.p.x, y: diffY + this.parameters.p.y };

                // start minus middle
                const sAngle = Math.atan2(
                    (this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2),
                    (this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                );

                // end minus middle
                const pAngle = Math.atan2(
                    (current.y - this.parameters.box.y - this.parameters.box.height / 2),
                    (current.x - this.parameters.box.x - this.parameters.box.width / 2),
                );

                const angle = this.parameters.rotation + (pAngle - sAngle) * 180 / Math.PI + this.options.snapToAngle / 2;

                // We have to move the element to the center of the box first and change the rotation afterwards
                // because rotation always works around a rotation-center, which is changed when moving the element
                // We also set the new rotation center to the center of the box.
                this.el
                    .center(this.parameters.box.cx, this.parameters.box.cy)
                    .rotate(angle - (angle % this.options.snapToAngle), this.parameters.box.cx, this.parameters.box.cy);
            };
            break;

        // Moving one single Point (needed when an element is deepSelected which means you can move every single point of the object)
        case 'point':
            this.calc = function (diffX, diffY) {
                // Snapping the point to the grid
                const snap = this.snapToGrid(diffX, diffY, this.parameters.pointCoords[0], this.parameters.pointCoords[1]);

                // Get the point array
                const array = this.el.array().valueOf();

                // Changing the moved point in the array
                array[this.parameters.i][0] = this.parameters.pointCoords[0] + snap[0];
                array[this.parameters.i][1] = this.parameters.pointCoords[1] + snap[1];

                // And plot the new this.el
                this.el.plot(array);
            };
        }

        this.el.fire('resizestart', { dx: this.parameters.x, dy: this.parameters.y, event });
        // When resizing started, we have to register events for...
        // Touches.
        SVG.on(window, 'touchmove.resize', (e) => {
            _this.update(e || window.event);
        });
        SVG.on(window, 'touchend.resize', () => {
            _this.done();
        });
        // Mouse.
        SVG.on(window, 'mousemove.resize', (e) => {
            _this.update(e || window.event);
        });
        SVG.on(window, 'mouseup.resize', () => {
            _this.done();
        });
    };

    /**
     * The update-function redraws the element every time the mouse is moving
     *
     *  @param {MouseEvent} event Mouse event.
     */
    ResizeHandler.prototype.update = function (event) {
        if (!event) {
            if (this.lastUpdateCall) {
                this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
            }
            return;
        }

        // Calculate the difference between the mouseposition at start and now
        const txPt = this._extractPosition(event);
        const p = this.transformPoint(txPt.x, txPt.y);

        const diffX = p.x - this.parameters.p.x;
        const diffY = p.y - this.parameters.p.y;

        this.lastUpdateCall = [diffX, diffY];

        // Calculate the new position and height / width of the element
        this.calc(diffX, diffY);

        // Emit an event to say we have changed.
        this.el.fire(
            'resizing',
            { dx: diffX, dy: diffY, event },    // Will be saved into detail field of the final event object.
        );
    };

    // Is called on mouseup.
    // Removes the update-function from the mousemove event
    ResizeHandler.prototype.done = function () {
        this.lastUpdateCall = null;
        SVG.off(window, 'mousemove.resize');
        SVG.off(window, 'mouseup.resize');
        SVG.off(window, 'touchmove.resize');
        SVG.off(window, 'touchend.resize');
        this.el.fire('resizedone');
    };

    // The flag is used to determine whether the resizing is used with a left-Point (first bit) and top-point (second bit)
    // In this cases the temp-values are calculated differently
    ResizeHandler.prototype.snapToGrid = function (diffX, diffY, flag, pointCoordsY) {
        let temp;

        // If `pointCoordsY` is given, a single Point has to be snapped (deepSelect). That's why we need a different temp-value
        if (typeof pointCoordsY !== 'undefined') {
            // Note that flag = pointCoordsX in this case
            temp = [
                (flag + diffX) % this.options.snapToGrid,
                (pointCoordsY + diffY) % this.options.snapToGrid,
            ];
        } else {
            // We check if the flag is set and if not we set a default-value (both bits set - which means upper-left-edge)
            flag = flag == null ? 1 | 1 << 1 : flag;
            temp = [
                (this.parameters.box.x + diffX + (flag & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid,
                (this.parameters.box.y + diffY + (flag & (1 << 1) ? 0 : this.parameters.box.height)) % this.options.snapToGrid,
            ];
        }

        if (diffX < 0) {
            temp[0] -= this.options.snapToGrid;
        }
        if (diffY < 0) {
            temp[1] -= this.options.snapToGrid;
        }

        diffX -= (Math.abs(temp[0]) < this.options.snapToGrid / 2
            ? temp[0]
            : temp[0] - (diffX < 0 ? -this.options.snapToGrid : this.options.snapToGrid));
        diffY -= (Math.abs(temp[1]) < this.options.snapToGrid / 2
            ? temp[1]
            : temp[1] - (diffY < 0 ? -this.options.snapToGrid : this.options.snapToGrid));

        return this.constraintToBox(diffX, diffY, flag, pointCoordsY);
    };

    // keep element within constrained box
    ResizeHandler.prototype.constraintToBox = function (diffX, diffY, flag, pointCoordsY) {
        // return [diffX, diffY]
        const c = this.options.constraint || {};
        let orgX; let
            orgY;

        if (typeof pointCoordsY !== 'undefined') {
            orgX = flag;
            orgY = pointCoordsY;
        } else {
            orgX = this.parameters.box.x + (flag & 1 ? 0 : this.parameters.box.width);
            orgY = this.parameters.box.y + (flag & (1 << 1) ? 0 : this.parameters.box.height);
        }

        if (typeof c.minX !== 'undefined' && orgX + diffX < c.minX) {
            diffX = c.minX - orgX;
        }

        if (typeof c.maxX !== 'undefined' && orgX + diffX > c.maxX) {
            diffX = c.maxX - orgX;
        }

        if (typeof c.minY !== 'undefined' && orgY + diffY < c.minY) {
            diffY = c.minY - orgY;
        }

        if (typeof c.maxY !== 'undefined' && orgY + diffY > c.maxY) {
            diffY = c.maxY - orgY;
        }

        return [diffX, diffY];
    };

    ResizeHandler.prototype.checkAspectRatio = function (snap, isReverse) {
        if (!this.options.saveAspectRatio) {
            return snap;
        }

        const updatedSnap = snap.slice();
        const aspectRatio = this.parameters.box.width / this.parameters.box.height;
        const newW = this.parameters.box.width + snap[0];
        const newH = this.parameters.box.height - snap[1];
        const newAspectRatio = newW / newH;

        if (newAspectRatio < aspectRatio) {
            // Height is too big. Adapt it
            updatedSnap[1] = newW / aspectRatio - this.parameters.box.height;
            isReverse && (updatedSnap[1] = -updatedSnap[1]);
        } else if (newAspectRatio > aspectRatio) {
            // Width is too big. Adapt it
            updatedSnap[0] = this.parameters.box.width - newH * aspectRatio;
            isReverse && (updatedSnap[0] = -updatedSnap[0]);
        }

        return updatedSnap;
    };

    SVG.extend(SVG.Element, {
        // Resize element with mouse
        resize(options) {
            (this.remember('_resizeHandler') || new ResizeHandler(this)).init(options || {});

            return this;
        },

    });

    SVG.Element.prototype.resize.defaults = {
        snapToAngle: 0.1, // Specifies the speed the rotation is happening when moving the mouse
        snapToGrid: 1, // Snaps to a grid of `snapToGrid` Pixels
        constraint: {}, // keep element within constrained box
        saveAspectRatio: false, // Save aspect ratio when resizing using lt, rt, rb or lb points
    };
}).call(this);
